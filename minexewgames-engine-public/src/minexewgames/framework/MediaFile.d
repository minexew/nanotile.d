/*
    Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

module minexewgames.framework.MediaFile;

import minexewgames.framework.crc16ccitt;
import minexewgames.framework.stream;

import std.algorithm;
import std.container;
import std.conv;
import std.stdint;
import std.c.string;

// TODO: optimize seek forward
// TODO: mediafile corruption handling
// TODO: prevent corruption from opening section multiple times

// specification-defined
enum uint16_t BITSTREAM_BINARY =             0x0A89;
enum uint16_t BITSTREAM_VER =                 0x0101;

enum uint32_t SECT_MIN_SIZE =                 256;
enum uint32_t SECT_MAX_SIZE =               (1 << 30) - 1;

enum uint32_t SECTION_DESC_MAX_LENGTH =     32767 - 31;
enum uint32_t METADATA_MAX_ENTRY_LENGTH =   32767 - 31;

enum uint32_t OFFSET_SECTION_MAP =          16;
enum METADATA_SECTION_NAME =                  "media.Metadata";

enum uint8_t NO_COMPRESSION[4] =            [0x00, 0x00, 0x00, 0x00];
enum uint8_t ZLIB_COMPRESSION[4] =          ['Z', 'L', 'I', 'B'];

// implementation-defined
enum uint32_t SECT_DEFAULT_SIZE =           1024;

static immutable ubyte zeros[32];

struct zmfSpan_t {
    uint32_t    sect_first;
    uint32_t    sect_count;
};

struct zmfBlock_t {
    uint64_t    length;
    zmfSpan_t   first_span;
};

static assert(zmfSpan_t.sizeof == 8,        "Size of zmfSpan_t");
static assert(zmfBlock_t.sizeof == 16,         "Size of zmfBlock_t");

class MediaFileException : Exception {
    this(string msg) {
        super(msg);
    }
}

/// Zombie Media File
/// See_Also:
///        $(LINK https://github.com/minexew/minexewgames-engine-public/blob/master/doc/zmf2.txt)
class MediaFile {
public:
    /// Flush all open streams and close the file.
    /// Make sure there are no open sections when calling this method!
    void close() {
        if (metadata !is null) {
            metadata.close();
            metadata = null;
        }
        
        if (reclaimed_sects !is null) {
            reclaimed_sects.close();
            reclaimed_sects = null;
        }

        if (section_map !is null) {
            section_map.close();
            section_map = null;
        }

        if (file !is null) {
            file.close();
            file = null;
        }
    }

    /// Open the specified Media File.
    bool open(string fileName, bool readOnly, bool canCreate) {
        return open(new StdOpenFile(), fileName, readOnly, canCreate);
    }
    
    /// Open the specified Media File using the OpenFile interface.
    bool open(OpenFile iof, string fileName, bool readOnly, bool canCreate) {
        close();
        isReadOnly = readOnly;
    
        file = iof.openFile(fileName, readOnly, false);
    
        if (file is null) {
            if (!readOnly && canCreate) {
                file = iof.openFile(fileName, readOnly, true);
    
                if (file is null) {
                    exception("Failed to open or create file.");
                    return false;
                }
    
                section_map =       new BlockStream(this, readOnly, file, OFFSET_SECTION_MAP);
                metadata =          null;
                reclaimed_sects =   null;
    
                if (!initMediaFile(sectorSize))
                    return false;
            }
            else {
                exception("Failed to open file.");
                return false;
            }
        }
        else {
            if (!openMediaFile())
                return false;
        }
    
        return true;
    }
    
    /// Open a stream as Media File.
    bool open(IOStream ios, bool readOnly) {
        close();
        isReadOnly = readOnly;
    
        file = ios;
    
        if (file.size() < 16) {
            if (!readOnly) {
                section_map =       new BlockStream(this, readOnly, file, OFFSET_SECTION_MAP);
                metadata =          null;
                reclaimed_sects =   null;
    
                if (!initMediaFile(sectorSize))
                    return false;
            }
            else {
                exception("Failed to open file.");
                return false;
            }
        }
        else {
            if (!openMediaFile())
                return false;
        }
    
        return true;
    }

    /// Retrieve a metadata value.
    /// Example: string authoringApp = mediaFile.getMetadata("media.authored_using");
    string getMetadata(string key) {
        string value;
        
        iterateMetadata(delegate int(uint16_t key_crc16, string key_in, string value_in) {
            if (key_in == key) {
                value = value_in;
                return -1;
            }
            else
                return 1;
        });

        return value;
    }
    
    /// Set metadata value for the given key.
    /// Example: mediaFile.setMetadata("media.authored_by", username);
    bool setMetadata(string key, string value) {
        // TODO: What if we detect corruption?
    
        if (isReadOnly)
            return false;
    
        immutable uint16_t new_key_crc16 = crc16ccitt(cast(ubyte*) key.ptr, key.length);
        immutable size_t new_data_len = key.length + 1 + value.length;
        immutable size_t new_data_len_padded = ((new_data_len + 31) & ~31);
    
        if (new_data_len > METADATA_MAX_ENTRY_LENGTH)
            return false;
    
        int rc = openMetadataSection(false);
    
        if (rc <= 0)
            return false;
    
        for (metadata.setPosition(0); metadata.readable(); ) {
            uint16_t data_len, data_len_padded, key_crc16;
            auto startPos = metadata.getPosition();
    
            int valid = readMetadataEntryHeader(data_len, data_len_padded, key_crc16);
    
            if (valid < 0)
                return false;
    
            if (!valid) {
                if (!metadata.seek(data_len_padded))
                    return false;
    
                continue;
            }
    
            char *rd_key;
            char *rd_value;
    
            if (!readMetadataEntryData(data_len, data_len_padded, rd_key, rd_value))
                return false;
    
            if (key_crc16 == new_key_crc16
                    && strlen(rd_key) == key.length && strncmp(rd_key, key.ptr, key.length) == 0) {
                metadata.setPosition(startPos);
    
                if (new_data_len_padded == data_len_padded)
                    break;
                else
                {
                    metadata.writeLE!uint16_t(0x8000 | data_len);
                    metadata.seek(2 + data_len_padded);
    
                    while (metadata.readable()) {
                        if (!readMetadataEntryHeader(data_len, data_len_padded, key_crc16))
                            return false;
    
                        if (!metadata.seek(data_len_padded))
                            return false;
                    }
                }
            }
        }
    
        metadata.writeLE!uint16_t(cast(uint16_t) new_data_len);
        metadata.writeLE!uint16_t(new_key_crc16);
    
        metadata.writeBytes(key.ptr, key.length);
        metadata.writeLE!char('=');
        metadata.writeBytes(value.ptr, value.length);
    
        metadata.writeBytes(zeros.ptr, new_data_len_padded - new_data_len);
    
        return true;
    }
    
    /// Iterate through all metadata entries.
    int iterateMetadata(int delegate(uint16_t key_crc16, string key, string value) listener) {
        char *rd_key;
        char *rd_value;
    
        int rc = openMetadataSection(true);
    
        if (rc <= 0)
            return rc;
    
        for (metadata.setPosition(0); metadata.readable(); ) {
            uint16_t data_len, data_len_padded, key_crc16;
    
            int valid = readMetadataEntryHeader(data_len, data_len_padded, key_crc16);
    
            if (valid < 0)
                return -1;
    
            if (!valid)
            {
                if (!metadata.seek(data_len_padded))
                    return -1;
    
                continue;
            }
    
            if (!readMetadataEntryData(data_len, data_len_padded, rd_key, rd_value))
                return -1;
    
            int ret = listener(key_crc16, to!string(rd_key), to!string(rd_value));
    
            if (ret <= 0)
                return ret;
        }
    
        return 0;
    }

    /// Open an existing section in the Media File.
    /// The first section with matching name will be opened.
    /// Returns: An IOStream or null if no such section exists.
    IOStream openSection(string name) {
        return openSectionPriv(name);
    }

    /// Create a new section with the given name.
    IOStream createSection(string name) {
        return createSectionPriv(name);
    }
    
    /// Open an existing section in the Media File.
    /// If no section with matching name is found, a new one will be created.
    IOStream openOrCreateSection(string name) {
        IOStream section = openSectionPriv(name);
    
        if (section is null)
            section = createSectionPriv(name);
    
        return section;
    }
    
    /// Iterate all sections in the Media File.
    int iterateSections(int delegate(uint16_t name_crc16, string name, string desc, const uint8_t compression[4],
            uint64_t data_length, uint64_t compressed_length) listener) {
        char *rd_name;
        char *rd_desc;

        for (section_map.setPosition(0); section_map.readable(); ) {
            uint16_t desc_len, desc_len_padded, name_crc16;
            uint8_t compression[4];
            uint64_t data_length;
            zmfBlock_t block;

            int valid = readSectionEntryHeader(desc_len, desc_len_padded, name_crc16, compression, data_length, block);

            if (valid < 0)
                return false;

            if (!valid) {
                if (!section_map.seek(desc_len_padded))
                    return false;

                continue;
            }

            if (!readSectionEntryData(desc_len, desc_len_padded, rd_name, rd_desc))
                return false;

            int ret = listener(name_crc16, to!string(rd_name), to!string(rd_desc), compression,
                    data_length, block.length);

            if (ret <= 0)
                return ret;
        }

        return 0;
    }

    /// Get a textual description of the bitstream type.
    string getBitstreamType() {
        if ((bitstream & 0xFFFF) == BITSTREAM_BINARY)
            return "BINARY-" ~ to!string(bitstream >> 16, 16) ~ "h";
        else
            return "UNKNOWN-???";
    }
    
    /// Get the total size of the Media File, in bytes.
    uint64_t getFileSize() {
        return file.size();
    }
    
    /// Get the size of one sector in the Media File, in bytes.
    uint32_t getSectorSize() {
        return sectorSize;
    }
    
    /// Set sector size for the Media File.
    /// Only effective when a new Media File is created.
    bool setSectorSize(uint32_t sectorSize) {
        if (sectorSize < SECT_MIN_SIZE || sectorSize > SECT_MAX_SIZE) {
            exception("Sector size must be between " ~ to!string(SECT_MIN_SIZE) ~ " and "
                ~ to!string(SECT_MAX_SIZE) ~ " bytes, inclusive.");
            return false;
        }
    
        if ((sectorSize & (sectorSize - 1)) != 0) {
            exception("Sector size must be a power of 2.");
            return false;
        }
    
        this.sectorSize = sectorSize;
        return true;
    }

protected:
    bool initMediaFile(uint32_t sectorSize) {
        bitstream = (BITSTREAM_VER << 16) | BITSTREAM_BINARY;

        if (!file.setPosition(0)
            // signature
            || !file.writeBytes("ZMF2".ptr, 4)
            // bitstream
            || !file.writeLE!uint32_t(bitstream)
            // sect_size
            || !file.writeLE!uint32_t(sectorSize)
            // ctlsect
            || !file.writeLE!uint32_t(0)

            || !section_map.writeDesc(file))
        {
            exception("Failed to write file header.");
            //return false;
        }
    
        return true;
    }
    
    bool openMediaFile() {
        char[4] magic;
        uint32_t sect_size;
        uint32_t ctlsect;
    
        if (!file.readBytes(magic.ptr, 4) || memcmp(magic.ptr, "ZMF2".ptr, 4) != 0
                || !file.readLE!uint32_t(&bitstream)) {
            exception("Not a Zombie media file.");
            return false;
        }
    
        if (bitstream != ((BITSTREAM_VER << 16) | BITSTREAM_BINARY)) {
            exception("Unrecognized bitstream type/version.");
            return false;
        }

        section_map =       new BlockStream(this, isReadOnly, file, OFFSET_SECTION_MAP);
        metadata =          null;
        reclaimed_sects =   null;
    
        if (!file.readLE!uint32_t(&sect_size)
            || !file.readLE!uint32_t(&ctlsect)
            || !section_map.readDesc(file)) {
            exception("Failed to read file header.");
            return false;
        }
    
        // TODO: Verify sect_size, ctlsect
        sectorSize = sect_size;
    
        return true;
    }

    void exception(string msg) { throw new MediaFileException(msg); }
    void errCorrupted() { exception("The media file is corrupted."); }
    void errLimit() { exception("A format limit was exceeded."); }
    void errReadOnly() { exception("The file is read-only."); }
    void errWrite() { exception("Failed to write data. (disk full?)"); }

    // metadata
    int openMetadataSection(bool readOnly) {
        if (metadata !is null)
            return 1;
    
        metadata = openSectionPriv(METADATA_SECTION_NAME);
    
        if (metadata !is null)
            return 1;
    
        if (readOnly)
            return 0;
    
        metadata = createSectionPriv(METADATA_SECTION_NAME);
    
        return (metadata !is null) ? 1 : -1;
    }
    
    int readMetadataEntryHeader(out uint16_t data_len, out uint16_t data_len_padded, out uint16_t key_crc16) {
        if (!metadata.readLE!uint16_t(&data_len)
            || !metadata.readLE!uint16_t(&key_crc16))
            return -1;
    
        // clear highest bit, round up to 32 bytes
        data_len_padded = (cast(uint16_t)(data_len + 31) & ~0x801F);
    
        if (data_len & 0x8000)
            return 0;
        else
            return 1;
    }
    
    bool readMetadataEntryData(uint16_t data_len, uint16_t data_len_padded,
            out char* key, out char* value) {
        data.length = data_len + 1;
    
        if (metadata.readBytes(data.ptr, data_len) != data_len)
            return false;
    
        if (!metadata.seek(data_len_padded - data_len))
            return false;
    
        data[data_len] = 0;
    
        char* delim = strchr(data.ptr, '=');
    
        if (delim == null)
            return false;
    
        *delim = 0;
    
        key = data.ptr;
        value = delim + 1;
        return true;
    }

    // section map
    int readSectionEntryHeader(out uint16_t desc_len, out uint16_t desc_len_padded, out uint16_t name_crc16,
            out uint8_t[4] compression, out uint64_t data_length, out zmfBlock_t block) {
        if (!section_map.readLE!uint16_t(&desc_len)
            || !section_map.readLE!uint16_t(&name_crc16)
            || section_map.readBytes(compression.ptr, 4) != 4
            || !section_map.readLE!uint64_t(&data_length)
            || !section_map.readLE!uint64_t(&block.length)
            || !section_map.readLE!uint32_t(&block.first_span.sect_first)
            || !section_map.readLE!uint32_t(&block.first_span.sect_count))
            return -1;
    
        // clear highest bit, round up to 32 bytes
        desc_len_padded = (cast(uint16_t)(desc_len + 31) & ~0x801F);
    
        if (desc_len & 0x8000)
            return 0;
        else
            return 1;
    }
    
    bool readSectionEntryData(uint16_t desc_len, uint16_t desc_len_padded,
        out char* name, out char* desc) {
        // make sure we won't need to reallocate data after doing strchr
        data.length = desc_len * 2 + 1;
    
        if (section_map.readBytes(data.ptr, desc_len) != desc_len)
            return false;
    
        if (!section_map.seek(desc_len_padded - desc_len))
            return false;
    
        data[desc_len] = 0;
    
        char* delim = strchr(data.ptr, '=');
    
        if (delim == null)
            return false;
    
        delim++;
        char* delim2 = strchr(delim, ',');
    
        if (delim2 == null)
            delim2 = delim + strlen(delim);
    
        data.length = desc_len + 1 + delim2 - delim + 1;
    
        memcpy(&data.ptr[desc_len + 1], delim, delim2 - delim);
        data[desc_len + 1 + delim2 - delim] = 0;
    
        name = &data.ptr[desc_len + 1];
        desc = data.ptr;
        return true;
    }

    IOStream createSectionPriv(string name) {
        // TODO: What if we detect corruption?
    
        if (isReadOnly)
            errReadOnly();
    
        string new_desc = "name=" ~ name;
    
        immutable uint16_t new_name_crc16 = crc16ccitt(cast(ubyte*) name.ptr, name.length);
        immutable size_t new_desc_len = new_desc.length;
        immutable size_t new_desc_len_padded = ((new_desc_len + 31) & ~31);
    
        if (new_desc_len > SECTION_DESC_MAX_LENGTH)
            errLimit();
    
        for (section_map.setPosition(0); section_map.readable(); ) {
            uint16_t desc_len, desc_len_padded, name_crc16;
            uint8_t compression[4];
            uint64_t data_length;
            zmfBlock_t block;
    
            auto startPos = section_map.getPosition();
            int valid = readSectionEntryHeader(desc_len, desc_len_padded, name_crc16, compression, data_length, block);
    
            if (valid < 0)
                errCorrupted();
    
            if (!valid) {
                if (desc_len_padded == new_desc_len_padded) {
                    section_map.setPosition(startPos);
                    break;
                }
    
                if (!section_map.seek(desc_len_padded))
                    errCorrupted();
    
                continue;
            }
    
            char *rd_key;
            char *rd_value;
    
            if (!readSectionEntryData(desc_len, desc_len_padded, rd_key, rd_value))
                errCorrupted();
        }
    
        if (!section_map.writeLE!uint16_t(cast(uint16_t) new_desc_len)
                || !section_map.writeLE!uint16_t(new_name_crc16)
                || section_map.writeBytes(NO_COMPRESSION.ptr, 4) != 4
                || !section_map.writeLE!uint64_t(0))
            errWrite();
    
        uint64_t pos = section_map.getPosition();
        BlockStream stream = new BlockStream(this, false, section_map, pos, pos - 8);
    
        if (!stream.writeDesc(section_map))
            return null;
    
        section_map.writeBytes(new_desc.ptr, new_desc.length);
        section_map.writeBytes(zeros.ptr, new_desc_len_padded - new_desc_len);
    
        return stream;
    }
    
    IOStream openSectionPriv(string name) {
        char *rd_name;
        char *rd_desc;
    
        immutable uint16_t new_name_crc16 = crc16ccitt(cast(ubyte*) name.ptr, name.length);
    
        for (section_map.setPosition(0); section_map.readable(); ) {
            uint16_t desc_len, desc_len_padded, name_crc16;
            uint8_t compression[4];
            uint64_t data_length;
            zmfBlock_t block;
    
            int valid = readSectionEntryHeader(desc_len, desc_len_padded, name_crc16, compression, data_length, block);
    
            if (valid < 0)
                return null;
    
            if (!valid) {
                if (!section_map.seek(desc_len_padded))
                    return null;
    
                continue;
            }
    
            if (!readSectionEntryData(desc_len, desc_len_padded, rd_name, rd_desc))
                return null;
    
            if (name_crc16 == new_name_crc16
                    && strlen(rd_name) == name.length && strncmp(rd_name, name.ptr, name.length) == 0) {
                auto pos = section_map.getPosition() - desc_len_padded - 32;
    
                BlockStream stream = new BlockStream(this, isReadOnly, section_map, pos + 16, pos + 8);
                stream.readDesc(&block);
                return stream;
            }
        }
    
        return null;
    }

    IOStream file;
    bool isReadOnly;
    char data[];

    // media file properties
    uint32_t bitstream;
    uint32_t sectorSize = 1024;

    // control blocks
    BlockStream section_map;
    IOStream metadata, reclaimed_sects;
}

class BlockStream : IOStream
{
public:
    this(MediaFile mf, bool readOnly, OutputStream descWriteback, uint64_t descOffset,
            uint64_t data_length_offset = 0) {
        this.mf = mf;
        this.isReadOnly = readOnly;
        this.descWriteback = descWriteback;
        this.descOffset = descOffset;
        this.data_length_offset = data_length_offset;

        length = 0;
        first_span.sect_first = 0;
        first_span.sect_count = 0;

        updateDesc = false;

        setPosition(0);
    }

    ~this() {
        if (mf !is null)
            close();
    }

    override void close() {
        flush();
        mf = null;
    }
    
    override bool seekable() {
        return true;
    }
            
    void readDesc(const zmfBlock_t* desc) {
        length = desc.length;
        first_span = desc.first_span;

        pos = 0;
        curr_span_in_stream = 0;
    }
    
    bool readDesc(InputStream file) {
        if (!file.readLE!uint64_t(&length)
            || !file.readLE!uint32_t(&first_span.sect_first)
            || !file.readLE!uint32_t(&first_span.sect_count))
            return false;
    
        pos = 0;
        curr_span_in_stream = 0;
    
        return true;
    }
    
    bool writeDesc(OutputStream file) {
        if (!file.writeLE!uint64_t(length)
            || !file.writeLE!uint32_t(first_span.sect_first)
            || !file.writeLE!uint32_t(first_span.sect_count))
            mf.errWrite();
    
        return true;
    }

    override bool readable() {
        return pos < length;
    }
    
    override bool writeable() {
        return !isReadOnly;
    }
    
    override void flush() {
        // if block length has changed, we need to update its description
        if (updateDesc) {
            // section blocks have their length stored in two places
            if (data_length_offset != 0)
                descWriteback.setPosition(data_length_offset) && descWriteback.writeLE(length);
    
            descWriteback.setPosition(descOffset) && writeDesc(descWriteback);
        }
    }

    override uint64_t getPosition() {
        return pos;
    }
    
    override bool setPosition(uint64_t pos) {
        if (pos > length)
            return false;
    
        // don't do any actual seeking; just change the internal pointer
        // and invalidate current span
        this.pos = pos;
        curr_span.sect_first = 0;
    
        return true;
    }
    
    override uint64_t size() {
        return length;
    }

    override size_t readBytes(void* buffer, size_t count) {
        // clamp read length
        if (count > pos + length)
            count = cast(size_t)(length - pos);
    
        if (count == 0)
            return 0;
    
        uint8_t* buffer_out = cast(uint8_t*) buffer;
    
        size_t read_total = 0;
    
        for (;;) {
            // start by checking whether we currently are within any span
            // and seek if not
            if (!isValid(curr_span) && !jumpToPos())
                return read_total;
    
            // how many bytes from current pos till the end of this span?
            immutable uint64_t maxRemainingBytesInSpan = curr_span.sect_count * mf.sectorSize - curr_span_pos;
    
            // are there any more spans for this block? if so, last 8 bytes are used for chaining
            immutable int64_t remainingBytesInSpan = maxRemainingBytesInSpan
                - (curr_span_in_stream + curr_span.sect_count * mf.sectorSize < length ? 8 : 0);
    
            if (remainingBytesInSpan > 0 && cast(uint) remainingBytesInSpan >= count) {
                // all the remaining data to be read is within the current span
    
                mf.file.setPosition(curr_span.sect_first * mf.sectorSize + curr_span_pos);
                auto read = mf.file.readBytes(buffer_out, count);
    
                curr_span_pos += read;
                pos += read;
                read_total += read;
    
                return read_total;
            }
            else {
                // there are more data to be read beyond this span
                // start by reading the rest of this one, then jump for more
    
                // are there ANY more data in this span? if so, read it
                if (remainingBytesInSpan > 0) {
                    mf.file.setPosition(curr_span.sect_first * mf.sectorSize + curr_span_pos);
                    auto read = mf.file.readBytes(buffer_out, cast(size_t) remainingBytesInSpan);
    
                    curr_span_pos += read;
                    pos += read;
                    read_total += read;
    
                    if (read < cast(uint) remainingBytesInSpan)
                        return read_total;
    
                    buffer_out += read;
                    count -= read;
                }
                else
                    mf.file.setPosition(curr_span.sect_first * mf.sectorSize + curr_span_pos + remainingBytesInSpan);
    
                zmfSpan_t next_span;
    
                // read the tag for next span
                if (!mf.file.readLE!uint32_t(&next_span.sect_first)
                    || !mf.file.readLE!uint32_t(&next_span.sect_count))
                    return read_total;
    
                if (!canJumpTo(curr_span, next_span))
                    return read_total;
    
                // loop for next span
                curr_span_in_stream += curr_span.sect_count * mf.sectorSize - 8;
                setCurrent(&next_span);
            }
        }
    }
    
    override size_t writeBytes(const void* buffer, size_t count) {
        if (isReadOnly || count == 0)
            return 0;
    
        const(uint8_t)* buffer_in = cast(const(uint8_t)*) buffer;
    
        size_t written_total = 0;
    
        for (;;) {
            // start by checking whether we currently are within any span
    
            if (!isValid(curr_span)) {
                if (length == 0) {
                    // the block is empty; allocate initial span
    
                    if (!allocateSpan(&first_span, count))
                        return written_total;
    
                    setCurrent(&first_span);
                    curr_span_in_stream = 0;
    
                    // we'll have to update first_span in block desc
                    updateDesc = true;
                }
                else
                    // seek; will fail if pos > length
                    if (!jumpToPos())
                        return written_total;
            }
    
            // we now have a valid span to write into
            // if the span has a chaining tag on its end, the usable capacity will be 8 bytes less
            // in that case we might have to fetch or allocate more spans
    
            // how many bytes from current pos till the end of this span?
            immutable uint64_t maxRemainingBytesInSpan = curr_span.sect_count * mf.sectorSize - curr_span_pos;
    
            immutable uint64_t newLength = max(length, pos + count);
    
            // are there/will there be any more spans beyond this one? if so, last 8 bytes are used for chaining
            immutable int64_t remainingBytesInSpan = maxRemainingBytesInSpan
                - (curr_span_in_stream + curr_span.sect_count * mf.sectorSize < newLength ? 8 : 0);
    
            if (remainingBytesInSpan > 0 && cast(uint) remainingBytesInSpan >= count) {
                // all the remaining data to be written will within the current span
    
                mf.file.setPosition(curr_span.sect_first * mf.sectorSize + curr_span_pos);
                auto written = mf.file.writeBytes(buffer_in, count);
    
                curr_span_pos += written;
                pos += written;
                written_total += written;
    
                if (pos > length) {
                    length = pos;
                    updateDesc = true;
                }
    
                return written_total;
            }
            else {
                // we'll have to go beyond this span
                // if there is a chaining tag already, we'll take the jump,
                // otherwise we have to allocate a new span
    
                immutable int64_t affectedBytesInSpan = maxRemainingBytesInSpan - 8;
    
                // will be > 8 if the block already continues beyond this span;
                // in that case the last 8 bytes contain a chaining tag which will be used
    
                // if 1..8, the current span contains data within its last 8 bytes
                // which will have to be moved
                immutable int64_t tailLength = length - (curr_span_in_stream + curr_span.sect_count * mf.sectorSize) + 8;
    
                // will ANY more data fit in this span?
                if (affectedBytesInSpan > 0) {
                    mf.file.setPosition(curr_span.sect_first * mf.sectorSize + curr_span_pos);
                    auto written = mf.file.writeBytes(buffer_in, cast(size_t) affectedBytesInSpan);
    
                    curr_span_pos += written;
                    pos += written;
                    written_total += written;
    
                    if (pos > length) {
                        length = pos;
                        updateDesc = true;
                    }
    
                    if (written < cast(uint) affectedBytesInSpan)
                        return written_total;
    
                    buffer_in += written;
                    count -= written;
                }
                else
                    mf.file.setPosition(curr_span.sect_first * mf.sectorSize + curr_span_pos + affectedBytesInSpan);
    
                if (tailLength > 8) {
                    zmfSpan_t next_span;
    
                    // read the tag for next span
                    if (!mf.file.readLE!uint32_t(&next_span.sect_first)
                        || !mf.file.readLE!uint32_t(&next_span.sect_count))
                        return written_total;
    
                    if (!canJumpTo(curr_span, next_span))
                        return false;
    
                    // loop for next span
                    curr_span_in_stream += curr_span.sect_count * mf.sectorSize - 8;
                    setCurrent(&next_span);
                }
                else {
                    // current data ends within this span; we might have to copy a couple of bytes
                    // if they are to be rewritten with the chaining tag
    
                    uint8_t tail[8];
    
                    if (tailLength > 0)
                        if (mf.file.readBytes(tail.ptr, cast(size_t) tailLength) != cast(size_t) tailLength)
                            return written_total;
    
                    zmfSpan_t new_span;
    
                    // allocate a new span
                    if (!allocateSpan(&new_span, count))
                        return written_total;
    
                    // write chaining tag
                    if (!mf.file.setPosition((curr_span.sect_first + curr_span.sect_count) * mf.sectorSize - 8)
                        || !mf.file.writeLE!uint32_t(new_span.sect_first)
                        || !mf.file.writeLE!uint32_t(new_span.sect_count))
                        return written_total;
    
                    // jump to new span
                    curr_span_in_stream += curr_span.sect_count * mf.sectorSize - 8;
                    setCurrent(&new_span);
    
                    // flush saved data (if any) and loop for the newly allocated span
                    if (tailLength > 0) {
                        if (!mf.file.setPosition(curr_span.sect_first * mf.sectorSize)
                            || mf.file.writeBytes(tail.ptr, cast(size_t) tailLength) != cast(size_t) tailLength)
                            return written_total;
    
                        curr_span_pos = tailLength;
                    }
                }
            }
        }
    }

protected:
    bool allocateSpan(zmfSpan_t* span, uint64_t sizeNeeded) {
        immutable uint64_t fileSize = mf.file.size();

        // always round up to next sector
        immutable uint64_t sect_first = (fileSize + mf.sectorSize - 1) / mf.sectorSize;
        immutable uint64_t sect_count = (sizeNeeded + mf.sectorSize - 1) / mf.sectorSize;
    
        if (sect_first > UINT32_MAX || sect_count > UINT32_MAX)
            return false;
    
        span.sect_first = cast(uint32_t) sect_first;
        span.sect_count = cast(uint32_t) sect_count;
    
        mf.file.setPosition(span.sect_first * mf.sectorSize + mf.sectorSize - 1);
        mf.file.writeLE!uint8_t(0);
    
        return true;
    }
    
    static bool canJumpTo(const ref zmfSpan_t from, const ref zmfSpan_t to) {
        // is the destination a valid allocated span different from the origin?
        return to.sect_first != 0 && to.sect_count != 0 && to.sect_first != from.sect_first;
    }
    
    static bool isValid(const ref zmfSpan_t span) {
        // is this an allocated span?
        return span.sect_first != 0;
    }
    
    bool jumpToPos() {
        // this is highly unoptimal right now (and possibly broken)
        // we're always starting from the block beginning and going span-by-span
    
        setCurrent(&first_span);
        curr_span_in_stream = 0;
    
        if (pos > length)
            return false;
    
        while (pos != curr_span_in_stream) {
            // this should never happen
            if (curr_span_in_stream > length)
                return false;
    
            immutable uint64_t maxPossibleBytesInSpan = curr_span.sect_count * mf.sectorSize;
    
            // does this span have an 8-byte tag at its end?
            // we can find out by checking whether it contains the rest of the block
            immutable uint64_t bytesInSpan = maxPossibleBytesInSpan
                - (curr_span_in_stream + maxPossibleBytesInSpan < length ? 8 : 0);
    
            // is the 'pos' we're looking for within this span?
            if (pos <= curr_span_in_stream + bytesInSpan) {
                curr_span_pos = pos - curr_span_in_stream;
                break;
            }
    
            zmfSpan_t next_span;
    
            // read the tag for next span
            if (!mf.file.setPosition(curr_span.sect_first * mf.sectorSize + bytesInSpan)
                || !mf.file.readLE!uint32_t(&next_span.sect_first)
                || !mf.file.readLE!uint32_t(&next_span.sect_count))
                return false;
    
            setCurrent(&next_span);
            curr_span_in_stream += bytesInSpan;
        }
    
        return true;
    }
    
    void setCurrent(const zmfSpan_t* span) {
        curr_span.sect_first = span.sect_first;
        curr_span.sect_count = span.sect_count;
        curr_span_pos = 0;
    }
    
    MediaFile mf;
    bool isReadOnly;
    OutputStream descWriteback;
    uint64_t descOffset, data_length_offset;

    // block desc
    uint64_t    length;
    zmfSpan_t   first_span;

    bool        updateDesc;

    // stream control
    uint64_t    pos;

    zmfSpan_t   curr_span;
    uint64_t    curr_span_in_stream, curr_span_pos;
}

unittest {
    import std.datetime;
    import std.file;
    import std.random;
    import std.stdio;
    
    enum testFileName = "_test.zmf";
    
    try {
        std.file.remove(testFileName);
    } catch (FileException ex) {
    }
    
    auto mediaFile = new MediaFile();
    mediaFile.open(testFileName, false, true);
    
    TickDuration[1] bench;
    
    // Basic metadata tests
    enum key1 = "media.test.key";
    enum key2 = "media.test.another_key";
    enum value1 = "Test Value";
    enum value2 = "Longer Test Value";
    enum value3 = "Yet Another Test Value";
    
    assert(mediaFile.setMetadata(key1, value3));
    assert(mediaFile.setMetadata(key1, value1));
    assert(mediaFile.setMetadata(key2, value2));
    assert(mediaFile.getMetadata(key1) == value1);
    
    // Test a 16 MiB random-data section
    enum size = 16 * 1024 * 1024;
    enum sectionName = "media.test.RandomData";
    
    ubyte[] data = new ubyte[size];
    
    void generateData() {
        for (size_t i = 0; i < data.length; i++)
            data[i] = cast(ubyte) uniform(0, 256);
    }
    
    bench = benchmark!(generateData)(1);
    writefln("[minexewgames.framework.MediaFile]\tGenerating Data: %s ms", bench[0].msecs);
    
    void writeToMediaFile() {
        OutputStream os = mediaFile.openOrCreateSection(sectionName);
        os.writeBytes(data.ptr, data.length);
        os.close();
    }
    
    bench = benchmark!(writeToMediaFile)(1);
    writefln("[minexewgames.framework.MediaFile]\tWriting Data: %s ms", bench[0].msecs);
    
    ubyte[] data2 = new ubyte[size];
    
    void readFromMediaFile() {
        InputStream os = mediaFile.openSection(sectionName);
        assert(os.readBytes(data2.ptr, data2.length) == data2.length);
    }
    
    bench = benchmark!(readFromMediaFile)(1);
    writefln("[minexewgames.framework.MediaFile]\tReading Data: %s ms", bench[0].msecs);
    
    assert(data == data2);
    
    // Reopen file as read-only and recheck metadata
    mediaFile.close();
    mediaFile.open(testFileName, true, false);
    
    assert(mediaFile.getMetadata(key1) == value1);
    assert(mediaFile.getMetadata(key2) == value2);
    
    mediaFile.close();
}
