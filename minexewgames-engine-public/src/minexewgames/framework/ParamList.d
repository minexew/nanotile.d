/*
    Boost Software License - Version 1.0 - August 17th, 2003
    
    Permission is hereby granted, free of charge, to any person or organization
    obtaining a copy of the software and accompanying documentation covered by
    this license (the "Software") to use, reproduce, display, distribute,
    execute, and transmit the Software, and to prepare derivative works of the
    Software, and to permit third-parties to whom the Software is furnished to
    do so, all subject to the following:
    
    The copyright notices in the Software and this entire statement, including
    the above license grant, this restriction and the following disclaimer,
    must be included in all copies of the Software, in whole or in part, and
    all derivative works of the Software, unless such copies or derivative
    works are solely in the form of machine-executable object code generated by
    a source language processor.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
    SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
    FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
    ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

module minexewgames.framework.ParamList;

import minexewgames.framework.annotationUtil;
import minexewgames.framework.types;

import core.stdc.ctype;
import std.array;
import std.conv;

/// Class to manipulate comma-separated, colon-delimited key-value pairs.
class ParamList
{
    // Note: this whole thing is completely UTF-8-agnostic, therefore it's OK to manipluate plain ol' chars.

public:
    /// Build a parameter list from the specified arguments
    static string build(string[2][] pairs...) {
        char[] params = new char[64];
        size_t used = 0;
        
        foreach (int i, pair; pairs) {
            if (i != 0)
                copyInto(params, used, ",");
                
            escapeInto(params, used, pair[0]);
            copyInto(params, used, "=");
            escapeInto(params, used, pair[1]);
        }
        
        return cast(string) params[0..used];
    }
    ///
    unittest {
        string colors = ParamList.build(["red", "#ff0000"], ["green", "#00ff00"], ["blue", "#0000ff"]);
        assert(colors == "red=#ff0000,green=#00ff00,blue=#0000ff");
        
        string paramsAsParam = ParamList.build(["output", "stylesheet"], ["basicColors", colors]);
        assert(paramsAsParam == "output=stylesheet,basicColors=red\\=#ff0000\\,green\\=#00ff00\\,blue\\=#0000ff");
        
        string colorsBack = ParamList.getValueForKey(paramsAsParam, "basicColors");
        assert(colorsBack == colors);
    }

    /// Get the value for the specified key
    static string getValueForKey(string params, string key) {
        char[] keyNoDup, valueNoDup;
        
        while (nextPairNoDup(params, keyNoDup, valueNoDup)) {
            if (keyNoDup == key)
                return valueNoDup.dup;
        }

        return null;
    }
    ///
    unittest {
        enum paramList1 = "path=media/random_file.zmf,mode=copy,useVfs=false";
    
        assert(ParamList.getValueForKey(paramList1, "path") == "media/random_file.zmf");
        assert(ParamList.getValueForKey(paramList1, "mode") == "copy");
        assert(ParamList.getValueForKey(paramList1, "useVfs") == "false");
    }

    /*int IsValidWithBuffers(const char* possiblyParams, char* keyBuffer, size_t keyBufferSize, char* valueBuffer, size_t valueBufferSize)
    {
        if (possiblyParams == nullptr)
            return PARAMS_EMPTY;

        if (keyBufferSize < 1 || valueBufferSize < 1)
            // can't really work with that
            return PARAMS_INVALID;

        auto p_params = possiblyParams;
        int validity = PARAMS_EMPTY;

        for (;;)
        {
            // skip whitespace, bail out on ';'
            while (true)
            {
                if (isspace(*p_params))
                    p_params++;
                else if (*p_params == ';' || *p_params == 0)
                    return validity;
                else
                    break;
            }

            if (!s_Unescape(p_params, keyBuffer, keyBufferSize, '='))
                // buffer overflow, consider invalid
                return PARAMS_INVALID;

            if (keyBuffer[0] == 0 || *p_params != '=')
                // malformed param set (key musn't be null)
                return false;

            p_params++;

            if (!s_Unescape(p_params, valueBuffer, valueBufferSize, ','))
                // buffer overflow, same as above
                return PARAMS_INVALID;

            if (*p_params == ',')
                p_params++;

            validity = PARAMS_VALID;
        }
    }*/

    /// Parse a key-value pair, advancing the orignal string.
    static bool nextPair(ref string params, out string key, out string value) {
        char[] keyNoDup, valueNoDup;
        
        if (nextPairNoDup(params, keyNoDup, valueNoDup)) {
            key = keyNoDup.dup;
            value = valueNoDup.dup;
            return true;
        }
        else
            return false;
    }
    ///
    unittest {
        string params = "red=#f00, green=#0f0, blue=#00f";
        string key, value;
        
        assert(ParamList.nextPair(params, key, value));
        assert(key == "red" && value == "#f00");
        
        assert(ParamList.nextPair(params, key, value));
        assert(key == "green" && value == "#0f0");
        
        assert(ParamList.nextPair(params, key, value));
        assert(key == "blue" && value == "#00f");
        
        assert(!ParamList.nextPair(params, key, value));
    }

    static bool nextPairNoDup(ref string params, out char[] key, out char[] value) {
        // skip whitespace, bail out on ';'
        while (!params.empty) {
            if (isspace(params[0]))
                params = params[1..$];
            else if (params[0] == ';')
                return false;
            else
                break;
        }

        if (params.empty)
            return false;

        key = unescape(params, s_keyBuffer, '=');

        if (key.empty || params.empty || params[0] != '=')
            // malformed param set (key musn't be null)
            return false;

        params = params[1..$];

        value = unescape(params, s_valueBuffer, ',');

        if (!params.empty && params[0] == ',')
            params = params[1..$];

        return true;
    }
    
    static void parseIntoStructure(Struct)(ref Struct data, string params,
            void function(string fieldName) error = null) {
        foreach (fieldName; __traits(allMembers, Struct)) {
            static if (typeof(__traits(getOverloads, Struct, fieldName)).length == 0) {
                alias Field = typeof(__traits(getMember, Struct, fieldName));
    
                enum required = HasAnnotation!(Struct, fieldName, Required);
                
                string value = ParamList.getValueForKey(params, fieldName);
                
                static if (required) {
                    if (value is null) {
                        if (error)
                            error(fieldName);
                        else
                            throw new Exception("Failed to parse structure '" ~ Struct.stringof
                                    ~ "' - missing required param '" ~ fieldName ~ "'");
                    }
                }
                else {
                    if (value is null)
                        continue;
                }
                
                static if (is(Field == bool)) {
                    try {
                        // allow bools to be specified as 0/1
                        __traits(getMember, data, fieldName) = (to!int(value) > 0);
                        continue;
                    } catch(ConvException ex) {
                    }
                }
                
                __traits(getMember, data, fieldName) = to!Field(value);
            }
        }
    }
    
private:
    this() {}

    static char[] s_keyBuffer;
    static char[] s_valueBuffer;

    static int needsEscaping(char c) {
        /* escaped characters:
            '\\'    because it's used for escaping itself
            '='     key-value delimiter, escaped to reduce confusion when reading embedded params
            ','     key-value separator, needs to be escaped for embedding
            ';'     marks the end of a param set (currently not implemented elsewhere)
        */

        if (c == '\\' || c == '=' || c == ',' || c == ';')
            return 1;
        else
            return 0;
    }

    static void copyInto(ref char[] destination, ref size_t used, string source) {
        foreach (c; source) {
            if (used + 1 >= destination.length)
                destination.length *= 2;
            
            destination[used++] = c;
        }
    }

    static void escapeInto(ref char[] destination, ref size_t used, string source) {
        foreach (c; source) {
            if (used + 2 >= destination.length)
                destination.length *= 2;
            
            if (!needsEscaping(c))
                destination[used++] = c;
            else {
                destination[used++] = '\\';
                destination[used++] = c;
            }
        }
    }

    static char[] unescape(ref string params, ref char[] buffer, char delim) {
        if (buffer.empty)
            buffer = new char[64];
        
        size_t used = 0;
        size_t i;
        
        for (i = 0; i < params.length && params[i] != delim && params[i] != ';'; i++) {
            if (params[i] == '\\' && i + 1 < params.length)
                i++;
                
            if (used + 1 >= buffer.length)
                buffer.length *= 2;
                
            buffer[used++] = params[i];
        }

        params = params[i..$];
        return buffer[0..used];
    }
}

